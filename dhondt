#!/usr/bin/env python3

#
# A few different formulas for quotients.
# - the D'Hondt formula is the most restrictive with small parties
# - the Sainte-Lague formula is less restrictive with small parties
# - the Modified Sainte-Lague formula is even less restrictive
#

# the D'Hondt formula
def dhondt_formula(votes, seats):
    return votes / (seats + 1)

# the Sainte-Lague formula
def sl_formula(votes, seats):
    return votes / (2 * seats + 1)

# the Modified Sainte-Lague formula
def modified_sl_formula(votes, seats):
    divisor = 1.4 if seats == 0 else 2 * seats + 1
    return votes / divisor

# Calculates the number of seats for each party using the given quotient
# formula.
#
# - party_votes is a dictionary with party names and their number of votes.
# - seats is the total number of seats to allocate.
# - quotient_formula is the function to be applied to calculate the quotient of votes / seats
#   and can be one the above-defined ones: DHondt, Sainte-Lague, Modified Sainte-Lague
# - resultDict is passed for the result, containing a dictionary with party names and number of seats.
#
# Returns the lenght of the result dictionary. If it's 0, there may be an error
#
def proportional_seats(party_votes, total_seats, quotient_formula, resultDict):
    # Calculate the quotients matrix (list in this case).
    quot = []
    resultDict.clear()
    for p in party_votes:
        resultDict[p] = 0
        for s in range(0, total_seats):
            q = quotient_formula(party_votes[p], s)
            quot.append((q, p))

    # Sort the quotients by value.
    quot.sort(reverse=True)

    # Take the highest quotients with the assigned parties.
    for s in range(0, total_seats):
        resultDict[quot[s][1]] += 1

    return len(resultDict)

# Loads voting data from the given stream.
#
# - Lines starting with "#" are considered comments.
# - Empty lines are ignored.
# - The first valid line contains the total number of seats.
# - Party names and number of votes are separated with semicolons.
#
# Returns a tuple (total_seats, votes) with total_seats being a number and votes
# being a dictionary.
#
def load_data(stream):
    total_seats = 0
    have_seats = False
    votes = dict()
    numLine = 0
    for line in stream:
        numLine += 1
        print("line #%d" % numLine, file=sys.stderr)
        if line.startswith("#"):
            continue
        line = line.strip()
        if len(line) == 0:
            continue
        if not have_seats:
            total_seats = int(line)
            have_seats = True
        else:
            fields = line.split(";")
            (party_str, votes_str) = tuple(fields)
            votes[party_str] = int(votes_str)
    return (total_seats, votes)

import sys
# Get file names.
try:
    output_filename = sys.argv[2]
except IndexError:
    output_filename = None
try:
    input_filename = sys.argv[1]
except IndexError:
    input_filename = None

# Load input data.
try:
    with open(input_filename, "r") if not input_filename == None else sys.stdin as stream:
        (total_seats, votes) = load_data(stream)
except IOError:
    sys.exit("Unable to open data file")
except ValueError:
    sys.exit("Invalid line in data file")

# Calculate seats.
dhondt_seats = dict()
proportional_seats(votes, total_seats, dhondt_formula, dhondt_seats)
sl_seats = dict()
proportional_seats(votes, total_seats, sl_formula, sl_seats)
modified_sl_seats = dict()
proportional_seats(votes, total_seats, modified_sl_formula, modified_sl_seats)

# Calculate percentages.
total_votes = sum(votes.values())
votes_pct = dict((p, votes[p] / total_votes * 100) for p in votes)
dhondt_seats_pct = dict(
        (p, dhondt_seats[p] / total_seats * 100) for p in dhondt_seats)
sl_seats_pct = dict(
        (p, sl_seats[p] / total_seats * 100) for p in sl_seats)
modified_sl_seats_pct = dict(
        (p, modified_sl_seats[p] / total_seats * 100)
        for p in modified_sl_seats)

# Write results as an HTML table.
import locale
sorted_parties = [(votes[p], p) for p in votes]
sorted_parties.sort(reverse=True)
sorted_parties = [x[1] for x in sorted_parties]

try:
    with open(output_filename, "w") if not output_filename == None else sys.stdout as out:
        def xprint(something):
            return print(something, file=out)

        xprint("<html><head>")
        xprint('<meta http-equiv="Content-Type" '
                + 'content="text/html; charset=%s" />'
                % (locale.getpreferredencoding(), ))
        xprint("<title>seats distribution, file %s</title>"
                % ("[unknown name]" if input_filename == None else input_filename, ))
        xprint('<style type="text/css">')
        xprint("    th, td { padding: 0 .25ex; }")
        xprint("    body { font-family: monospace; }")
        xprint("</style>")
        xprint("</head><body><table border=1>")
        xprint("<tr>" 
                + "<th>Party</th><th>Votes</th><th>Votes %</th>"
                + "<th>DH seats</th><th>DH %</th>"
                + "<th>SL seats</th><th>SL %</th>"
                + "<th>MSL seats</th><th>MSL %</th>"
                + "</tr>"
                )
        for p in sorted_parties:
            xprint("<tr>")
            xprint("<td>%s</td>" % (p, ))
            xprint("<td>%s</td>" % (votes[p], ))
            xprint("<td>%.2f</td>" % (votes_pct[p], ))
            xprint("<td>%s</td>" % (dhondt_seats[p], ))
            xprint("<td>%.2f</td>" % (dhondt_seats_pct[p], ))
            xprint("<td>%s</td>" % (sl_seats[p], ))
            xprint("<td>%.2f</td>" % (sl_seats_pct[p], ))
            xprint("<td>%s</td>" % (modified_sl_seats[p], ))
            xprint("<td>%.2f</td>" % (modified_sl_seats_pct[p], ))
            xprint("</tr>")
        xprint("</table></body></html>")
except IOError:
    sys.exit("Unable to write results to output file")
